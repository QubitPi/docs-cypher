:description: This section contains an overview of operators.
[[query-operators]]
= Operators

This page contains an overview of the available Cypher operators.

[[query-operators-summary]]
== Operators at a glance


[subs=none]
|===
| xref::syntax/operators.adoc#query-operators-aggregation[Aggregation operators] | `DISTINCT`
| xref::syntax/operators.adoc#query-operators-property[Property operators] | `.` for static property access, `[]` for dynamic property access, `=` for replacing all properties, `+=` for mutating specific properties
| xref::syntax/operators.adoc#query-operators-temporal[Temporal operators]   | `+` and `-` for operations between durations and temporal instants/durations, `*` and `/` for operations between durations and numbers
| xref::syntax/operators.adoc#query-operators-map[Map operators]       |  `.` for static value access by key, `[]` for dynamic value access by key
| xref::syntax/operators.adoc#query-operators-list[List operators]       | `+` and `\|\|` (list concatenation), `IN` to check existence of an element in a list, `[]` for accessing element(s) dynamically
|===


[[query-operators-aggregation]]
== Aggregation operators

The aggregation operators comprise:

* remove duplicates values: `DISTINCT`

[[syntax-using-the-distinct-operator]]
=== Using the `DISTINCT` operator

Retrieve the unique eye colors from `Person` nodes.

.Query
[source, cypher]
----
CREATE
  (a:Person {name: 'Anne', eyeColor: 'blue'}),
  (b:Person {name: 'Bill', eyeColor: 'brown'}),
  (c:Person {name: 'Carol', eyeColor: 'blue'})
WITH [a, b, c] AS ps
UNWIND ps AS p
RETURN DISTINCT p.eyeColor
----

Even though both *'Anne'* and *'Carol'* have blue eyes, *'blue'* is only returned once.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +p.eyeColor+
| +"blue"+
| +"brown"+

1+d|Rows: 2
|===

`DISTINCT` is commonly used in conjunction with xref::functions/aggregating.adoc[aggregating functions].


[[query-operators-property]]
== Property operators

The property operators pertain to a node or a relationship, and comprise:

* statically access the property of a node or relationship using the dot operator: `.`
* dynamically access the property of a node or relationship using the subscript operator: `[]`
* property replacement `=` for replacing all properties of a node or relationship
* property mutation operator `+=` for setting specific properties of a node or relationship


[[syntax-accessing-the-property-of-a-node-or-relationship]]
=== Statically accessing a property of a node or relationship using the `.` operator

////
[source, cypher, role=test-setup]
----
Match (a:Person) delete a;
----
////

.Query
[source, cypher]
----
CREATE
  (a:Person {name: 'Jane', livesIn: 'London'}),
  (b:Person {name: 'Tom', livesIn: 'Copenhagen'})
WITH a, b
MATCH (p:Person)
RETURN  p.name
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +p.name+
| +"Jane"+
| +"Tom"+

1+d|Rows: 2
|===


[[syntax-filtering-on-a-dynamically-computed-property-key]]
=== Filtering on a dynamically-computed property key using the `[]` operator

.Query
[source, cypher]
----
CREATE
  (a:Restaurant {name: 'Hungry Jo', rating_hygiene: 10, rating_food: 7}),
  (b:Restaurant {name: 'Buttercup Tea Rooms', rating_hygiene: 5, rating_food: 6}),
  (c1:Category {name: 'hygiene'}),
  (c2:Category {name: 'food'})
WITH a, b, c1, c2
MATCH (restaurant:Restaurant), (category:Category)
WHERE restaurant["rating_" + category.name] > 6
RETURN DISTINCT restaurant.name
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +restaurant.name+
| +"Hungry Jo"+

1+d|Rows: 1
|===

See also xref::clauses/where.adoc#filter-on-dynamic-properties[`WHERE` -> Filter on dynamic properties].

[NOTE]
====
The behavior of the `[]` operator with respect to `null` is detailed xref::values-and-types/working-with-null.adoc#cypher-null-bracket-operator[here].
====


[[syntax-property-replacement-operator]]
=== Replacing all properties of a node or relationship using the `=` operator

.Query
[source, cypher]
----
CREATE (a:Person {name: 'Sofia', age: 20})
WITH a
MATCH (p:Person {name: 'Sofia'})
SET p = {name: 'Ellen', livesIn: 'London'}
RETURN p.name, p.age, p.livesIn
----

All the existing properties on the node are replaced by those provided in the map; i.e. the `name` property is updated from `Sofia` to `Ellen`, the `age` property is deleted, and the `livesIn` property is added.

.Result
[role="queryresult",options="header,footer",cols="3*<m"]
|===
| +p.name+ | +p.age+ | +p.livesIn+
| +"Ellen"+ | +<null>+ | +"London"+

3+d|Rows: 1
|===

See xref::clauses/set.adoc#set-replace-properties-using-map[Replace all properties using a map and `=`] for more details on using the property replacement operator `=`.


[[syntax-property-mutation-operator]]
=== Mutating specific properties of a node or relationship using the `+=` operator

.Query
[source, cypher]
----
CREATE (a:Person {name: 'Sofia', age: 20})
WITH a
MATCH (p:Person {name: 'Sofia'})
SET p += {name: 'Ellen', livesIn: 'London'}
RETURN p.name, p.age, p.livesIn
----

The properties on the node are updated as follows by those provided in the map: the `name` property is updated from `Sofia` to `Ellen`, the `age` property is left untouched, and the `livesIn` property is added.

.Result
[role="queryresult",options="header,footer",cols="3*<m"]
|===
| +p.name+ | +p.age+ | +p.livesIn+
| +"Ellen"+ | +20+ | +"London"+

3+d|Rows: 1
|===

See xref::clauses/set.adoc#set-setting-properties-using-map[Mutate specific properties using a map and `+=`] for more details on using the property mutation operator `+=`.

[[query-operators-temporal]]
== Temporal operators

Temporal operators comprise:

* adding a xref::values-and-types/temporal.adoc#cypher-temporal-durations[`DURATION`] to either a xref::values-and-types/temporal.adoc#cypher-temporal-instants[temporal instant] or another `DURATION`: `+`
* subtracting a `DURATION` from either a temporal instant or another `DURATION`: `-`
* multiplying a `DURATION` with a number: `*`
* dividing a `DURATION` by a number: `/`

The following table shows -- for each combination of operation and operand type -- the type of the value returned from the application of each temporal operator:

[options="header"]
|===
| Operator | Left-hand operand | Right-hand operand | Type of result

| xref::syntax/operators.adoc#syntax-add-subtract-duration-to-temporal-instant[`+`]
| Temporal instant
| `DURATION`
| The type of the temporal instant

| xref::syntax/operators.adoc#syntax-add-subtract-duration-to-temporal-instant[`+`]
| `DURATION`
| Temporal instant
| The type of the temporal instant

| xref::syntax/operators.adoc#syntax-add-subtract-duration-to-temporal-instant[`-`]
| Temporal instant
| `DURATION`
| The type of the temporal instant

| xref::syntax/operators.adoc#syntax-add-subtract-duration-to-duration[`+`]
| `DURATION`
| `DURATION`
| `DURATION`

| xref::syntax/operators.adoc#syntax-add-subtract-duration-to-duration[`-`]
| `DURATION`
| `DURATION`
| `DURATION`

| xref::syntax/operators.adoc#syntax-multiply-divide-duration-number[`*`]
| `DURATION`
| xref::values-and-types/property-structural-constructed.adoc#property-types[Number]
| `DURATION`

| xref::syntax/operators.adoc#syntax-multiply-divide-duration-number[`*`]
| xref::values-and-types/property-structural-constructed.adoc#property-types[Number]
| `DURATION`
| `DURATION`

| xref::syntax/operators.adoc#syntax-multiply-divide-duration-number[`/`]
| `DURATION`
| xref::values-and-types/property-structural-constructed.adoc#property-types[Number]
| `DURATION`

|===


[[syntax-add-subtract-duration-to-temporal-instant]]
=== Adding and subtracting a `DURATION` to or from a temporal instant

.Query
[source, cypher]
----
WITH
  localdatetime({year:1984, month:10, day:11, hour:12, minute:31, second:14}) AS aDateTime,
  duration({years: 12, nanoseconds: 2}) AS aDuration
RETURN aDateTime + aDuration, aDateTime - aDuration
----

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +aDateTime + aDuration+ | +aDateTime - aDuration+
| +1996-10-11T12:31:14.000000002+ | +1972-10-11T12:31:13.999999998+

2+d|Rows: 1
|===

xref::values-and-types/temporal.adoc#cypher-temporal-duration-component[Components of a `DURATION`] that do not apply to the temporal instant are ignored.
For example, when adding a `DURATION` to a `DATE`, the _hours_, _minutes_, _seconds_ and _nanoseconds_ of the `DURATION` are ignored (`ZONED TIME` and `LOCAL TIME` behaves in an analogous manner):

.Query
[source, cypher]
----
WITH
  date({year:1984, month:10, day:11}) AS aDate,
  duration({years: 12, nanoseconds: 2}) AS aDuration
RETURN aDate + aDuration, aDate - aDuration
----

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +aDate + aDuration+ | +aDate - aDuration+
| +1996-10-11+ | +1972-10-11+
2+d|Rows: 1
|===

Adding two durations to a temporal instant is not an associative operation.
This is because non-existing dates are truncated to the nearest existing date:

.Query
[source, cypher]
----
RETURN
  (date("2011-01-31") + duration("P1M")) + duration("P12M") AS date1,
  date("2011-01-31") + (duration("P1M") + duration("P12M")) AS date2
----

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +date1+ | +date2+
| +2012-02-28+ | +2012-02-29+

2+d|Rows: 1
|===


[[syntax-add-subtract-duration-to-duration]]
=== Adding and subtracting a `DURATION` to or from another `DURATION`

.Query
[source, cypher]
----
WITH
  duration({years: 12, months: 5, days: 14, hours: 16, minutes: 12, seconds: 70, nanoseconds: 1}) as duration1,
  duration({months:1, days: -14, hours: 16, minutes: -12, seconds: 70}) AS duration2
RETURN duration1, duration2, duration1 + duration2, duration1 - duration2
----

.Result
[role="queryresult",options="header,footer",cols="4*<m"]
|===
| +duration1+ | +duration2+ | +duration1 + duration2+ | +duration1 - duration2+
| +P12Y5M14DT16H13M10.000000001S+ | +P1M-14DT15H49M10S+ | +P12Y6MT32H2M20.000000001S+ | +P12Y4M28DT24M0.000000001S+

4+d|Rows: 1
|===


[[syntax-multiply-divide-duration-number]]
=== Multiplying and dividing a `DURATION` with or by a number

These operations are interpreted simply as component-wise operations with overflow to smaller units based on an average length of units in the case of division (and multiplication with fractions).

.Query
[source, cypher]
----
WITH duration({days: 14, minutes: 12, seconds: 70, nanoseconds: 1}) AS aDuration
RETURN aDuration, aDuration * 2, aDuration / 3
----

.Result
[role="queryresult",options="header,footer",cols="3*<m"]
|===
| +aDuration+ | +aDuration * 2+ | +aDuration / 3+
| +P14DT13M10.000000001S+ | +P28DT26M20.000000002S+ | +P4DT16H4M23.333333333S+

3+d|Rows: 1
|===


[[query-operators-map]]
== Map operators

The map operators comprise:

* statically access the value of a map by key using the dot operator: `.`
* dynamically access the value of a map by key using the subscript operator: `[]`


[NOTE]
====
The behavior of the `[]` operator with respect to `null` is detailed in the xref::values-and-types/working-with-null.adoc#cypher-null-bracket-operator[working with null] page.
====


[[syntax-accessing-the-value-of-a-nested-map]]
=== Statically accessing the value of a nested map by key using the `.` operator

.Query
[source, cypher]
----
WITH {person: {name: 'Anne', age: 25}} AS p
RETURN  p.person.name
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +p.person.name+
| +"Anne"+

1+d|Rows: 1
|===


[[syntax-accessing-dynamic-map-parameter]]
=== Dynamically accessing the value of a map by key using the `[]` operator and a parameter

A parameter may be used to specify the key of the value to access:

.Parameters
[source, parameters]
----
{
  "myKey" : "name"
}
----

.Query
[source, cypher]
----
WITH {name: 'Anne', age: 25} AS a
RETURN a[$myKey] AS result
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +result+
| +"Anne"+

1+d|Rows: 1
|===

More information can be found in the xref::values-and-types/maps.adoc[Maps chapter].

[[query-operators-list]]
== List operators

The list operators comprise:

* concatenating lists `l~1~` and `l~2~`: `[l~1~] + [l~2~]` and `[l~1~] || [l~2~]`
* checking if an element `e` exists in a list `l`: `e IN [l]`
* dynamically accessing an element(s) in a list using the subscript operator: `[]`

[NOTE]
====
The behavior of the `IN` and `[]` operators with respect to `null` is detailed xref::values-and-types/working-with-null.adoc[here].
====


[[syntax-concatenating-two-lists]]
=== Concatenating two lists using `+`

.Query
[source, cypher]
----
RETURN [1,2,3,4,5] + [6,7] AS myList
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +myList+
| +[1,2,3,4,5,6,7]+

1+d|Rows: 1
|===


[[syntax-concatenating-two-lists-with-doublebar]]
=== Concatenating two lists using `||`

.Query
[source, cypher]
----
RETURN [1,2,3,4,5] || [6,7] AS myList
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| myList
| [1,2,3,4,5,6,7]

1+d|Rows: 1
|===


[[syntax-using-in-to-check-if-a-number-is-in-a-list]]
=== Using `IN` to check if a number is in a list

.Query
[source, cypher]
----
WITH [2, 3, 4, 5] AS numberlist
UNWIND numberlist AS number
WITH number
WHERE number IN [2, 3, 8]
RETURN number
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +number+
| +2+
| +3+

1+d|Rows: 2
|===


[[syntax-using-in-for-more-complex-list-membership-operations]]
=== Using `IN` for more complex list membership operations

The general rule is that the `IN` operator will evaluate to `true` if the list given as the right-hand operand contains an element which has the same _type and contents (or value)_ as the left-hand operand.
Lists are only comparable to other lists, and elements of a list `innerList` are compared pairwise in ascending order from the first element in `innerList` to the last element in `innerList`.

The following query checks whether or not the list `[2, 1]` is an element of the list `[1, [2, 1], 3]`:

.Query
[source, cypher]
----
RETURN [2, 1] IN [1, [2, 1], 3] AS inList
----

The query evaluates to `true` as the right-hand list contains, as an element, the list `[1, 2]` which is of the same type (a list) and contains the same contents (the numbers `2` and `1` in the given order) as the left-hand operand.
If the left-hand operator had been `[1, 2]` instead of `[2, 1]`, the query would have returned `false`.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +inList+
| +true+

1+d|Rows: 1
|===

At first glance, the contents of the left-hand operand and the right-hand operand _appear_ to be the same in the following query:

.Query
[source, cypher]
----
RETURN [1, 2] IN [1, 2] AS inList
----

However, `IN` evaluates to `false` as the right-hand operand does not contain an element that is of the same _type_ -- i.e. a _list_ -- as the left-hand-operand.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +inList+
| +false+

1+d|Rows: 1
|===

The following query can be used to ascertain whether or not a list -- obtained from, say, the xref::functions/list.adoc#functions-labels[labels()] function -- contains at least one element that is also present in another list:

[source, cypher]
----
MATCH (n)
WHERE size([label IN labels(n) WHERE label IN ['Person', 'Employee'] | 1]) > 0
RETURN count(n)
----

As long as `labels(n)` returns either `Person` or `Employee` (or both), the query will return a value greater than zero.


[[syntax-accessing-elements-in-a-list]]
=== Accessing elements in a list using the `[]` operator

.Query
[source, cypher]
----
WITH ['Anne', 'John', 'Bill', 'Diane', 'Eve'] AS names
RETURN names[1..3] AS result
----

The square brackets will extract the elements from the start index `1`, and up to (but excluding) the end index `3`.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +result+
| +["John","Bill"]+

1+d|Rows: 1
|===


[[syntax-accessing-element-in-a-list-parameter]]
=== Dynamically accessing an element in a list using the `[]` operator and a parameter

A parameter may be used to specify the index of the element to access:

.Parameters
[source, parameters]
----
{
  "myIndex" : 1
}
----

.Query
[source, cypher]
----
WITH ['Anne', 'John', 'Bill', 'Diane', 'Eve'] AS names
RETURN names[$myIndex] AS result
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +result+
| +"John"+

1+d|Rows: 1
|===


[[syntax-using-in-with-nested-list-subscripting]]
=== Using `IN` with `[]` on a nested list

`IN` can be used in conjunction with `[]` to test whether an element exists in a nested list:

.Query
[source, cypher]
----
WITH [[1, 2, 3]] AS l
RETURN 3 IN l[0] AS result
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +result+
| +true+

1+d|Rows: 1
|===

More details on lists can be found in xref::values-and-types/lists.adoc#cypher-lists-general[Lists in general].

